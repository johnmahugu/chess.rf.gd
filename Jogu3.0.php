<?php
/**
 * Jogu3.0.php - Jogu PHP Micro Framework + SleekDB v3.0 (Hybrid JSON + SQLite)
 * Version 3.0.0
 * Author: John "Kesh" Mahugu (original) + enhancements
 * Email: johnmahugu.at.gmail.com
 * Created: 15th September 2025
 * Enhanced: <?= date('jS F Y \@ H:i:s') ?>
 *
 * Backward compatibility:
 * - The database class is named `SleekDB` (same as earlier versions).
 * - Existing methods (`insert`, `find`, `findOne`, `update`, `delete`, `getDB`, `collection()`) keep working.
 *
 * New features:
 * - JSON file engine (default) for zero-dependency deployments.
 * - SQLite engine (via PDO) for scalable relational persistence.
 * - Fluid ORM-ish API: dispense/store/load/findBeans/trash.
 * - WAL (write-ahead log) for durability (opt-in).
 * - Optional per-collection indexes to speed equality queries (opt-in).
 * - Transactions supported when using SQLite driver.
 * - Batch operations, simple aggregation, caching, schema validation.
 *
 * Usage (default JSON):
 *   $app = new Jogu(false);
 *   $db = $app->getDB(); // returns SleekDB instance
 *   $db->collection('users')->insert(['name'=>'John']);
 *
 * Usage (SQLite):
 *   // pass options when constructing Jogu or instantiate SleekDB directly
 *   $db = new SleekDB(__DIR__.'/data', ['engine'=>'sqlite','sqlite_dsn'=>'sqlite:' . __DIR__ . '/app.db']);
 *
 * NOTE: Please test on a staging environment before switching production.
 */

/* ============================================================
   ==============  FRAMEWORK (Jogu)  ===========================
   ============================================================ */

class Jogu {
    protected $routes = [];
    protected $requestUri;
    protected $requestMethod;
    protected $prod = false;
    protected $baseDir;
    protected $sleekdb = null;
    protected $middleware = [];

    /**
     * Constructor
     * $prod boolean: production mode (silence errors) or dev
     * $dbOpts array: optional SleekDB constructor options to override defaults
     */
    public function __construct(bool $prod = false, array $dbOpts = []) {
        $this->prod = $prod;
        $this->requestUri = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH);
        $this->requestMethod = $_SERVER['REQUEST_METHOD'] ?? 'GET';
        $this->baseDir = $this->detectBaseDir();

        $this->createHtaccessIfNeeded();
        $this->createRequiredFolders();
        $this->createDefaultViews();

        if (!defined('BASE_URL')) {
            $scheme = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? "https" : "http";
            $host   = $_SERVER['HTTP_HOST'] ?? ($_SERVER['SERVER_NAME'] ?? 'localhost');
            define('BASE_URL', $scheme . "://" . $host . $this->baseDir);
        }

        // Initialize SleekDB with default options merged with provided dbOpts
        $defaultDbOpts = [
            'engine' => 'json',               // 'json' or 'sqlite'
            'enable_wal' => true,
            'enable_indexes' => true,
            'enable_cache' => true,
            'encryption_key' => null,         // optional AES-256-CBC key
            'json_path' => __DIR__ . '/data', // base path for JSON engine
            'sqlite_dsn' => 'sqlite:' . __DIR__ . '/data/app.db',
            'sqlite_user' => null,
            'sqlite_pass' => null,
            'auto_rebuild_indexes' => false
        ];
        $opts = array_merge($defaultDbOpts, $dbOpts);
        $this->sleekdb = new SleekDB($opts['json_path'], $opts);
    }

    protected function detectBaseDir(): string {
        $documentRoot = isset($_SERVER['DOCUMENT_ROOT']) ? realpath($_SERVER['DOCUMENT_ROOT']) : null;
        $frameworkDir = realpath(__DIR__);
        if (!$documentRoot || !$frameworkDir) return '/';
        $base = str_replace('\\', '/', substr($frameworkDir, strlen($documentRoot)));
        if ($base === false || $base === '') {
            return '/';
        }
        return '/' . trim($base, '/') . '/';
    }

    protected function createHtaccessIfNeeded() {
        $htaccessFile = __DIR__ . '/.htaccess';
        if (!file_exists($htaccessFile)) {
            $content = <<<HTACCESS
# Auto-generated by Jogu.php PHP Micro Framework
<IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteBase {$this->baseDir}
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule ^ index.php [L,QSA]
</IfModule>
HTACCESS;
            file_put_contents($htaccessFile, $content);
            @chmod($htaccessFile, 0644);
        }
    }

    protected function createRequiredFolders() {
        $folders = ['views', 'data', 'data/indexes', 'data/cache', 'data/migrations', 'data/schemas'];
        foreach ($folders as $folder) {
            $path = __DIR__ . '/' . $folder;
            if (!is_dir($path)) mkdir($path, 0755, true);
        }
    }

    protected function createDefaultViews() {
        $viewsDir = __DIR__ . '/views';
        $homeViewPath = $viewsDir . '/home.php';
        if (!file_exists($homeViewPath)) {
            $homeTemplate = <<<MYPHP
<?php /** Default Home View for Jogu v3.0 */ ?>
<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><title>Jogu v3.0</title></head>
<body>
<h1>Welcome to Jogu v3.0</h1>
<p>Lightweight microframework with integrated SleekDB (hybrid JSON + SQLite)</p>
<nav>
  <a href="<?php echo htmlspecialchars(\$app->link('/')); ?>">Home</a> |
  <a href="<?php echo htmlspecialchars(\$app->link('/about')); ?>">About</a>
</nav>
</body></html>
MYPHP;
            file_put_contents($homeViewPath, $homeTemplate);
            @chmod($homeViewPath, 0644);
        }
    }

    // Middleware registration
    public function use(callable $middleware) { $this->middleware[] = $middleware; }

    // Routes
    public function get(string $path, callable $callback) { $this->addRoute('GET', $path, $callback); }
    public function post(string $path, callable $callback) { $this->addRoute('POST', $path, $callback); }
    public function put(string $path, callable $callback) { $this->addRoute('PUT', $path, $callback); }
    public function delete(string $path, callable $callback) { $this->addRoute('DELETE', $path, $callback); }

    protected function addRoute(string $method, string $path, callable $callback) {
        $this->routes[] = ['method' => strtoupper($method), 'path' => rtrim($path, '/'), 'callback' => $callback];
    }

    public function listen() {
        $uri = $this->requestUri;
        if (strpos($uri, $this->baseDir) === 0) {
            $uri = '/' . substr($uri, strlen($this->baseDir));
        }

        foreach ($this->routes as $route) {
            if ($this->requestMethod !== $route['method']) continue;
            $params = $this->match($uri, $route['path']);
            if ($params !== false) {
                foreach ($this->middleware as $mw) { $mw(); }
                call_user_func_array($route['callback'], $params);
                return;
            }
        }
        $this->error404();
    }

    protected function match(string $requestUri, string $routePath) {
        $requestSegments = $this->splitPath($requestUri);
        $routeSegments = $this->splitPath($routePath);
        if (count($requestSegments) !== count($routeSegments)) return false;
        $params = [];
        foreach ($routeSegments as $index => $segment) {
            if (preg_match('/^\{(.+)\}$/', $segment, $matches)) {
                $params[$matches[1]] = $requestSegments[$index];
            } elseif ($segment !== $requestSegments[$index]) {
                return false;
            }
        }
        return $params;
    }

    protected function splitPath(string $path) {
        $trimmed = trim($path, '/');
        return $trimmed === '' ? [] : explode('/', $trimmed);
    }

    public function render(string $viewFile, array $data = []) {
        $viewPath = __DIR__ . '/views/' . $viewFile;
        if (!file_exists($viewPath)) { $this->error("View file not found: {$viewFile}"); return; }
        $data['app'] = $this;
        extract($data);
        include $viewPath;
    }

    public function link(string $path, bool $absolute = false): string {
        $base = rtrim($this->baseDir, '/');
        $path = '/' . ltrim($path, '/');
        return $absolute ? BASE_URL . ltrim($path, '/') : $base . $path;
    }

    public function url(string $path, array $params = []): string {
        $url = BASE_URL . ltrim($path, '/');
        if (!empty($params)) $url .= '?' . http_build_query($params);
        return $url;
    }

    protected function error404() {
        http_response_code(404);
        if (!$this->prod) {
            echo "<h1>404 Not Found</h1><p>The requested URL " . htmlspecialchars($this->requestUri) . " was not found on this server.</p>";
        } else {
            echo "Page not found.";
        }
        exit;
    }

    protected function error(string $msg) {
        http_response_code(500);
        if (!$this->prod) {
            echo "<h1>Error</h1><p>" . htmlspecialchars($msg) . "</p>";
        } else {
            echo "Application error.";
        }
        exit;
    }

    public function getDB() { return $this->sleekdb; }

    // Back-compat: shorthand to get collection
    public function collection(string $name) { return $this->sleekdb->collection($name); }
}

/* ============================================================
   ======================= SLEEKDB v3.0 ========================
   - Name preserved: SleekDB
   - Hybrid JSON (default) + SQLite (via PDO)
   - Backward-compatible API + ORM helpers
   ============================================================ */

class SleekDB {
    // basic config/state
    private $basePath;
    private $opts;
    private $engine;       // 'json'|'sqlite'
    private $collections = [];
    private $pdo = null;   // when engine is sqlite
    private $cache = [];   // in-memory cache
    private $indexes = []; // index metadata
    private $walEnabled = true;

    /**
     * Constructor
     * @param string $basePath JSON storage path (ignored if sqlite engine but used for defaults)
     * @param array $opts options:
     *    engine: 'json' or 'sqlite'
     *    enable_wal: true|false
     *    enable_indexes: true|false
     *    enable_cache: true|false
     *    encryption_key: null|string (AES-256-CBC)
     *    sqlite_dsn/sqlite_user/sqlite_pass
     */
    public function __construct(string $basePath = null, array $opts = []) {
        // if basePath is an opts array (compat), allow flexibility
        if (is_array($basePath) && empty($opts)) {
            $opts = $basePath;
            $basePath = $opts['json_path'] ?? (__DIR__ . '/data');
        }
        $this->basePath = rtrim($basePath ?? (__DIR__ . '/data'), '/');
        $this->opts = $opts;
        $this->engine = $opts['engine'] ?? 'json';
        $this->walEnabled = $opts['enable_wal'] ?? true;
        $this->opts['enable_indexes'] = $opts['enable_indexes'] ?? true;
        $this->opts['enable_cache'] = $opts['enable_cache'] ?? true;
        $this->opts['encryption_key'] = $opts['encryption_key'] ?? null;

        // Ensure base path exists for JSON features
        if (!is_dir($this->basePath)) mkdir($this->basePath, 0755, true);
        if (!is_dir($this->basePath . '/indexes')) mkdir($this->basePath . '/indexes', 0755, true);
        if (!is_dir($this->basePath . '/cache')) mkdir($this->basePath . '/cache', 0755, true);
        if (!is_dir($this->basePath . '/schemas')) mkdir($this->basePath . '/schemas', 0755, true);

        // Initialize engine-specific resources
        if ($this->engine === 'sqlite') {
            $dsn = $opts['sqlite_dsn'] ?? 'sqlite:' . $this->basePath . '/app.db';
            $user = $opts['sqlite_user'] ?? null;
            $pass = $opts['sqlite_pass'] ?? null;
            $this->pdo = new PDO($dsn, $user, $pass, [
                PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            ]);
            // meta table for schema tracking
            $this->pdo->exec("CREATE TABLE IF NOT EXISTS _sdb_meta (collection TEXT PRIMARY KEY, schema_json TEXT)");
        }

        // load existing indexes metadata if present
        $this->loadIndexes();

        // replay WAL to recover (if enabled)
        if ($this->walEnabled && $this->engine === 'json') {
            $this->replayWal();
        }
    }

    /* -------------------------
       Collection factory
       ------------------------- */

    public function collection(string $name) {
        if (!isset($this->collections[$name])) {
            $this->collections[$name] = new SleekCollection($name, $this);
        }
        return $this->collections[$name];
    }

    /* -------------------------
       Index metadata
       ------------------------- */

    private function indexMetadataFile() {
        return $this->basePath . '/indexes/main.json';
    }

    private function loadIndexes() {
        $file = $this->indexMetadataFile();
        if (file_exists($file)) {
            $this->indexes = json_decode(file_get_contents($file), true) ?: [];
        } else $this->indexes = [];
    }

    private function saveIndexes() {
        file_put_contents($this->indexMetadataFile(), json_encode($this->indexes, JSON_PRETTY_PRINT), LOCK_EX);
    }

    public function createIndex(string $collection, string $field, array $options = []) {
        $key = $collection . '.' . $field;
        if (isset($this->indexes[$key])) return $this;
        $this->indexes[$key] = [
            'collection' => $collection,
            'field' => $field,
            'unique' => $options['unique'] ?? false,
            'created_at' => date('c')
        ];
        $this->saveIndexes();
        // instruct collection to rebuild
        $this->collection($collection)->rebuildIndex($field);
        return $this;
    }

    /* -------------------------
       WAL (only for JSON engine)
       ------------------------- */

    public function walPathForCollection(string $collection) {
        return $this->basePath . '/' . $collection . '/_wal.log';
    }

    public function walAppend(string $collection, array $op) {
        if (!$this->walEnabled || $this->engine !== 'json') return;
        $path = $this->walPathForCollection($collection);
        $entry = json_encode(['ts' => microtime(true), 'op' => $op]) . PHP_EOL;
        file_put_contents($path, $entry, FILE_APPEND | LOCK_EX);
    }

    public function replayWal() {
        foreach (glob($this->basePath . '/*', GLOB_ONLYDIR) as $colDir) {
            $wal = $colDir . '/_wal.log';
            if (!file_exists($wal)) continue;
            $lines = file($wal, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
            if (empty($lines)) continue;
            $colName = basename($colDir);
            $col = $this->collection($colName);
            $col->acquireLock();
            foreach ($lines as $ln) {
                $entry = json_decode($ln, true);
                if (!$entry || !isset($entry['op'])) continue;
                $op = $entry['op'];
                try {
                    switch ($op['type']) {
                        case 'insert': $col->applyInsertFromWal($op['data']); break;
                        case 'update': $col->applyUpdateFromWal($op['id'], $op['data']); break;
                        case 'delete': $col->applyDeleteFromWal($op['id']); break;
                    }
                } catch (\Throwable $e) {
                    // continue best effort
                }
            }
            file_put_contents($wal, "");
            $col->releaseLock();
        }
    }

    /* -------------------------
       ORM helpers (back-compat)
       ------------------------- */

    public function dispense(string $type) {
        $bean = new stdClass();
        $bean->__type = $type;
        return $bean;
    }

    public function store($bean) {
        if (!is_object($bean) || !isset($bean->__type)) {
            throw new InvalidArgumentException("store() expects an object bean with __type.");
        }
        $collection = $bean->__type;
        $arr = [];
        foreach (get_object_vars($bean) as $k => $v) {
            if ($k === '__type') continue;
            $arr[$k] = $v;
        }
        if (isset($arr['_id'])) {
            $id = (string)$arr['_id'];
            unset($arr['_id']);
            return $this->collection($collection)->updateById($id, $arr) ? $id : null;
        }
        $arr['_type'] = $collection;
        $doc = $this->collection($collection)->insert($arr);
        return $doc['_id'] ?? null;
    }

    public function load(string $type, $id) {
        $doc = $this->collection($type)->findById((string)$id);
        if (!$doc) return null;
        $bean = new stdClass();
        $bean->__type = $type;
        foreach ($doc as $k => $v) $bean->$k = $v;
        return $bean;
    }

    public function findBeans(string $type, array $criteria = [], array $opts = []) {
        $criteria = array_merge(['_type' => $type], $criteria);
        $rows = $this->collection($type)->find($criteria, $opts);
        $beans = [];
        foreach ($rows as $r) {
            $b = new stdClass();
            $b->__type = $type;
            foreach ($r as $k => $v) $b->$k = $v;
            $beans[] = $b;
        }
        return $beans;
    }

    public function trash($beanOrId) {
        if (is_object($beanOrId)) {
            $id = $beanOrId->_id ?? null;
            $type = $beanOrId->__type ?? null;
            if (!$id || !$type) return false;
            return $this->collection($type)->deleteById($id);
        }
        return false;
    }

    /* -------------------------
       Backward-compatible CRUD top-level
       - insert/find/findOne/update/delete delegate to 'appstore' or _type
       ------------------------- */

    public function insert(array $data) {
        $collection = $data['_type'] ?? 'appstore';
        return $this->collection($collection)->insert($data);
    }

    public function find(array $criteria = [], array $opts = []) {
        $collection = $criteria['_type'] ?? 'appstore';
        if (isset($criteria['_type'])) unset($criteria['_type']);
        return $this->collection($collection)->find($criteria, $opts);
    }

    public function findOne(array $criteria = []) {
        $collection = $criteria['_type'] ?? 'appstore';
        if (isset($criteria['_type'])) unset($criteria['_type']);
        return $this->collection($collection)->findOne($criteria);
    }

    public function update(string $id, array $data) {
        $collection = $data['_type'] ?? 'appstore';
        return $this->collection($collection)->updateById($id, $data);
    }

    public function delete(string $id) {
        // best-effort: try appstore
        return $this->collection('appstore')->deleteById($id);
    }

    /* -------------------------
       Utilities
       ------------------------- */

    public function getBasePath() { return $this->basePath; }
    public function getIndexes() { return $this->indexes; }
    public function isCacheEnabled() { return $this->opts['enable_cache'] ?? false; }
    public function getCacheValue(string $key) {
        if (!$this->isCacheEnabled()) return null;
        if (isset($this->cache[$key]) && $this->cache[$key]['expires'] > time()) {
            return $this->cache[$key]['value'];
        }
        return null;
    }
    public function setCacheValue(string $key, $value, int $ttl = 3600) {
        if (!$this->isCacheEnabled()) return;
        $this->cache[$key] = ['value'=>$value, 'expires'=>time()+$ttl];
    }

    // sqlite transaction helper
    public function transaction(callable $callback) {
        if ($this->engine !== 'sqlite' || !$this->pdo) {
            throw new RuntimeException("Transactions supported only for sqlite engine.");
        }
        try {
            $this->pdo->beginTransaction();
            $res = $callback($this);
            $this->pdo->commit();
            return $res;
        } catch (\Throwable $e) {
            $this->pdo->rollBack();
            throw $e;
        }
    }

    public function generateId() {
        return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
            mt_rand(0, 0xffff), mt_rand(0, 0xffff),
            mt_rand(0, 0xffff),
            mt_rand(0, 0x0fff) | 0x4000,
            mt_rand(0, 0x3fff) | 0x8000,
            mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)
        );
    }
}

/* ============================================================
   =================== SleekCollection (per-collection) =========
   ============================================================ */

class SleekCollection {
    private $name;
    private $db;        // SleekDB instance
    private $path;      // path to collection (json files)
    private $lockHandle; // file lock handle
    private $indexDir;

    public function __construct(string $name, SleekDB $db) {
        $this->name = $name;
        $this->db = $db;
        $this->path = $db->getBasePath() . '/' . $name;
        $this->indexDir = $db->getBasePath() . '/indexes';
        if (!is_dir($this->path)) mkdir($this->path, 0755, true);
    }

    /* -------------------------
       Locking
       ------------------------- */
    public function acquireLock() {
        $lockFile = $this->path . '/.lock';
        $fh = fopen($lockFile, 'c');
        if (!$fh) throw new RuntimeException("Cannot open lock file: $lockFile");
        flock($fh, LOCK_EX);
        $this->lockHandle = $fh;
    }

    public function releaseLock() {
        if ($this->lockHandle) {
            flock($this->lockHandle, LOCK_UN);
            fclose($this->lockHandle);
            $this->lockHandle = null;
        }
    }

    /* -------------------------
       Insert
       ------------------------- */
    public function insert(array $document) {
        // schema validation if schema exists
        $schema = $this->db->loadSchema($this->name);
        if ($schema) {
            $v = $this->validateDocument($document, $schema);
            if (!$v['valid']) throw new RuntimeException('Schema validation failed: ' . implode('; ', $v['errors']));
        }

        $id = $document['_id'] ?? $this->db->generateId();
        $document['_id'] = (string)$id;
        $document['created_at'] = $document['created_at'] ?? date('c');
        $document['updated_at'] = $document['updated_at'] ?? date('c');

        $this->acquireLock();
        $payload = json_encode($document, JSON_PRETTY_PRINT);
        // optional encryption
        if (!empty($this->db->opts['encryption_key'])) {
            $payload = $this->encrypt($payload, $this->db->opts['encryption_key']);
        }
        file_put_contents($this->path . '/' . $document['_id'] . '.json', $payload, LOCK_EX);
        if ($this->db->walEnabled) $this->db->walAppend($this->name, ['type'=>'insert','data'=>$document]);
        $this->releaseLock();

        // update indexes (if any)
        $this->updateIndexesOnInsert($document);
        $this->db->emit('document.inserted', ['collection'=>$this->name,'document'=>$document]);
        return $document;
    }

    public function insertMany(array $docs) {
        $out = [];
        foreach ($docs as $d) $out[] = $this->insert($d);
        return $out;
    }

    /* -------------------------
       Read / Query
       ------------------------- */

    public function find(array $query = [], array $options = []) {
        $cacheKey = md5($this->name . '::' . serialize([$query, $options]));
        if ($this->db->isCacheEnabled()) {
            $c = $this->db->getCacheValue($cacheKey);
            if ($c !== null) return $c;
        }

        // try index usage (simple equality only)
        $files = $this->filesFromIndex($query);
        if ($files === null) {
            $files = glob($this->path . '/*.json');
        }

        $results = [];
        foreach ($files as $f) {
            $raw = file_get_contents($f);
            if (!empty($this->db->opts['encryption_key'])) $raw = $this->decrypt($raw, $this->db->opts['encryption_key']);
            $doc = json_decode($raw, true);
            if (!$doc) continue;
            if ($this->matchesQuery($doc, $query)) $results[] = $doc;
        }

        // sorting
        if (isset($options['sort'])) $results = $this->applySort($results, $options['sort']);
        // skip/limit
        if (isset($options['skip'])) $results = array_slice($results, (int)$options['skip']);
        if (isset($options['limit'])) $results = array_slice($results, 0, (int)$options['limit']);
        // projection
        if (isset($options['projection'])) $results = $this->applyProjection($results, $options['projection']);

        if ($this->db->isCacheEnabled()) $this->db->setCacheValue($cacheKey, $results);
        return $results;
    }

    public function findOne(array $query = []) {
        $r = $this->find($query, ['limit'=>1]);
        return $r ? $r[0] : null;
    }

    public function findById(string $id) {
        $file = $this->path . '/' . $id . '.json';
        if (!file_exists($file)) return null;
        $raw = file_get_contents($file);
        if (!empty($this->db->opts['encryption_key'])) $raw = $this->decrypt($raw, $this->db->opts['encryption_key']);
        return json_decode($raw, true);
    }

    /* -------------------------
       Update
       ------------------------- */

    public function updateById(string $id, array $data) {
        $file = $this->path . '/' . $id . '.json';
        if (!file_exists($file)) return null;
        $raw = file_get_contents($file);
        if (!empty($this->db->opts['encryption_key'])) $raw = $this->decrypt($raw, $this->db->opts['encryption_key']);
        $existing = json_decode($raw, true);
        if (!is_array($existing)) return null;

        $data['_id'] = $id;
        $data['created_at'] = $existing['created_at'] ?? date('c');
        $data['updated_at'] = date('c');

        $this->acquireLock();
        $payload = json_encode($data, JSON_PRETTY_PRINT);
        if (!empty($this->db->opts['encryption_key'])) $payload = $this->encrypt($payload, $this->db->opts['encryption_key']);
        file_put_contents($file, $payload, LOCK_EX);
        if ($this->db->walEnabled) $this->db->walAppend($this->name, ['type'=>'update','id'=>$id,'data'=>$data]);
        $this->releaseLock();

        $this->updateIndexesOnUpdate($existing, $data);
        $this->db->emit('document.updated', ['collection'=>$this->name,'document'=>$data]);
        return $data;
    }

    public function updateMany(array $query, array $updateDoc) {
        $docs = $this->find($query);
        $modified = 0;
        foreach ($docs as $d) {
            $id = $d['_id'];
            if (isset($updateDoc['$set'])) $new = array_merge($d, $updateDoc['$set']); else $new = array_merge($d, $updateDoc);
            $this->updateById($id, $new);
            $modified++;
        }
        return ['matched'=>count($docs),'modified'=>$modified];
    }

    /* -------------------------
       Delete
       ------------------------- */

    public function deleteById(string $id) {
        $file = $this->path . '/' . $id . '.json';
        if (!file_exists($file)) return false;
        $raw = file_get_contents($file);
        if (!empty($this->db->opts['encryption_key'])) $raw = $this->decrypt($raw, $this->db->opts['encryption_key']);
        $doc = json_decode($raw, true);
        $this->updateIndexesOnDelete($doc);
        $this->acquireLock();
        unlink($file);
        if ($this->db->walEnabled) $this->db->walAppend($this->name, ['type'=>'delete','id'=>$id]);
        $this->releaseLock();
        $this->db->emit('document.deleted', ['collection'=>$this->name,'document'=>$doc]);
        return true;
    }

    public function deleteMany(array $query) {
        $docs = $this->find($query);
        $deleted = 0;
        foreach ($docs as $d) {
            if ($this->deleteById($d['_id'])) $deleted++;
        }
        return ['deleted'=>$deleted];
    }

    /* -------------------------
       Aggregation (basic)
       ------------------------- */

    public function aggregate(array $pipeline) {
        $results = $this->find();
        foreach ($pipeline as $stage) {
            foreach ($stage as $op => $params) {
                switch ($op) {
                    case '$match':
                        $results = array_values(array_filter($results, function($doc) use ($params){ return $this->matchesQuery($doc, $params); }));
                        break;
                    case '$group':
                        $results = $this->group($results, $params);
                        break;
                    case '$sort':
                        $results = $this->applySort($results, $params);
                        break;
                    case '$limit':
                        $results = array_slice($results, 0, (int)$params);
                        break;
                    case '$skip':
                        $results = array_slice($results, (int)$params);
                        break;
                }
            }
        }
        return array_values($results);
    }

    /* -------------------------
       Index support
       ------------------------- */

    private function indexFile(string $field) {
        $safe = preg_replace('/[^a-z0-9_]+/i','_',$field);
        return $this->indexDir . '/' . $this->name . '_' . md5($field) . '.' . $safe . '.idx.json';
    }

    public function rebuildIndex(string $field) {
        $indexPath = $this->indexFile($field);
        $index = [];
        foreach (glob($this->path . '/*.json') as $file) {
            $raw = file_get_contents($file);
            if (!empty($this->db->opts['encryption_key'])) $raw = $this->decrypt($raw, $this->db->opts['encryption_key']);
            $data = json_decode($raw, true);
            if (isset($data[$field])) {
                $key = is_scalar($data[$field]) ? (string)$data[$field] : json_encode($data[$field]);
                $id = basename($file,'.json');
                $index[$key][] = $id;
            }
        }
        file_put_contents($indexPath, json_encode($index, JSON_PRETTY_PRINT), LOCK_EX);
    }

    private function canUseIndexSimple(array $query) {
        foreach ($this->db->getIndexes() as $key=>$meta) {
            if ($meta['collection'] !== $this->name) continue;
            $field = $meta['field'];
            if (isset($query[$field]) && !is_array($query[$field])) return $field;
        }
        return null;
    }

    private function filesFromIndex(array $query = []) {
        $field = $this->canUseIndexSimple($query);
        if ($field === null) return null;
        $idxFile = $this->indexFile($field);
        if (!file_exists($idxFile)) return null;
        $index = json_decode(file_get_contents($idxFile), true) ?: [];
        $val = is_scalar($query[$field]) ? (string)$query[$field] : json_encode($query[$field]);
        $ids = $index[$val] ?? [];
        $files = [];
        foreach ($ids as $id) $files[] = $this->path . '/' . $id . '.json';
        return $files;
    }

    private function updateIndexesOnInsert(array $doc) {
        foreach ($this->db->getIndexes() as $k=>$meta) {
            if ($meta['collection'] !== $this->name) continue;
            $field = $meta['field'];
            if (!isset($doc[$field])) continue;
            $idxFile = $this->indexFile($field);
            $index = file_exists($idxFile) ? json_decode(file_get_contents($idxFile), true) : [];
            $key = is_scalar($doc[$field]) ? (string)$doc[$field] : json_encode($doc[$field]);
            if (!isset($index[$key])) $index[$key] = [];
            if (!in_array($doc['_id'],$index[$key],true)) $index[$key][] = $doc['_id'];
            file_put_contents($idxFile, json_encode($index, JSON_PRETTY_PRINT), LOCK_EX);
        }
    }

    private function updateIndexesOnUpdate(array $old, array $new) {
        foreach ($this->db->getIndexes() as $k=>$meta) {
            if ($meta['collection'] !== $this->name) continue;
            $field = $meta['field'];
            $oldVal = $old[$field] ?? null;
            $newVal = $new[$field] ?? null;
            $idxFile = $this->indexFile($field);
            $index = file_exists($idxFile) ? json_decode(file_get_contents($idxFile), true) : [];
            if ($oldVal !== null) {
                $kOld = is_scalar($oldVal) ? (string)$oldVal : json_encode($oldVal);
                if (isset($index[$kOld])) {
                    $index[$kOld] = array_values(array_diff($index[$kOld], [$old['_id']]));
                    if (empty($index[$kOld])) unset($index[$kOld]);
                }
            }
            if ($newVal !== null) {
                $kNew = is_scalar($newVal) ? (string)$newVal : json_encode($newVal);
                if (!isset($index[$kNew])) $index[$kNew] = [];
                if (!in_array($new['_id'],$index[$kNew],true)) $index[$kNew][] = $new['_id'];
            }
            file_put_contents($idxFile, json_encode($index, JSON_PRETTY_PRINT), LOCK_EX);
        }
    }

    private function updateIndexesOnDelete(array $doc) {
        foreach ($this->db->getIndexes() as $k=>$meta) {
            if ($meta['collection'] !== $this->name) continue;
            $field = $meta['field'];
            if (!isset($doc[$field])) continue;
            $idxFile = $this->indexFile($field);
            $index = file_exists($idxFile) ? json_decode(file_get_contents($idxFile), true) : [];
            $key = is_scalar($doc[$field]) ? (string)$doc[$field] : json_encode($doc[$field]);
            if (isset($index[$key])) {
                $index[$key] = array_values(array_diff($index[$key], [$doc['_id']]));
                if (empty($index[$key])) unset($index[$key]);
                file_put_contents($idxFile, json_encode($index, JSON_PRETTY_PRINT), LOCK_EX);
            }
        }
    }

    /* -------------------------
       Query matching
       ------------------------- */

    public function matchesQuery(array $doc, array $query) {
        foreach ($query as $k=>$v) {
            if ($k === '$and') {
                foreach ($v as $cond) if (!$this->matchesQuery($doc,$cond)) return false;
                continue;
            }
            if ($k === '$or') {
                $ok = false; foreach ($v as $cond) if ($this->matchesQuery($doc,$cond)) { $ok = true; break; }
                if (!$ok) return false;
                continue;
            }
            if (is_array($v)) {
                foreach ($v as $op=>$val) {
                    switch ($op) {
                        case '$gt': if (!isset($doc[$k]) || !is_numeric($doc[$k]) || !($doc[$k] > $val)) return false; break;
                        case '$lt': if (!isset($doc[$k]) || !is_numeric($doc[$k]) || !($doc[$k] < $val)) return false; break;
                        case '$gte': if (!isset($doc[$k]) || !is_numeric($doc[$k]) || !($doc[$k] >= $val)) return false; break;
                        case '$lte': if (!isset($doc[$k]) || !is_numeric($doc[$k]) || !($doc[$k] <= $val)) return false; break;
                        case '$in': if (!isset($doc[$k]) || !in_array($doc[$k], (array)$val)) return false; break;
                        case '$contains': if (!isset($doc[$k]) || stripos((string)$doc[$k], (string)$val) === false) return false; break;
                        case '$regex': if (!isset($doc[$k]) || !preg_match($val, (string)$doc[$k])) return false; break;
                        default: return false;
                    }
                }
            } else {
                if (!isset($doc[$k]) || $doc[$k] !== $v) return false;
            }
        }
        return true;
    }

    /* -------------------------
       Helpers: sort/projection/group
       ------------------------- */

    private function applySort(array $rows, $sortSpec) {
        if (is_array($sortSpec) && isset($sortSpec['field'])) {
            $field = $sortSpec['field']; $dir = strtolower($sortSpec['dir'] ?? 'asc');
            usort($rows, function($a,$b) use ($field,$dir) {
                $va = $a[$field] ?? null; $vb = $b[$field] ?? null;
                if ($va == $vb) return 0;
                if ($dir === 'asc') return ($va < $vb) ? -1 : 1;
                return ($va > $vb) ? -1 : 1;
            });
        } else {
            foreach (array_reverse($sortSpec ?? []) as $field=>$dir) {
                $rows = $this->applySort($rows, ['field'=>$field,'dir'=>$dir]);
            }
        }
        return $rows;
    }

    private function applyProjection(array $rows, array $proj) {
        $out = [];
        foreach ($rows as $r) {
            $entry = [];
            foreach ($proj as $field) if (isset($r[$field])) $entry[$field] = $r[$field];
            $out[] = $entry;
        }
        return $out;
    }

    private function group(array $docs, $params) {
        $field = $params['by'] ?? null;
        if (!$field) return $docs;
        $out = [];
        foreach ($docs as $d) {
            $key = $d[$field] ?? '_null';
            if (!isset($out[$key])) $out[$key] = ['_id'=>$key,'count'=>0,'docs'=>[]];
            $out[$key]['count']++;
            $out[$key]['docs'][] = $d;
        }
        return array_values($out);
    }

    /* -------------------------
       Validation helpers
       ------------------------- */

    private function validateDocument(array $doc, array $schema) {
        $errors = [];
        foreach ($schema['required'] ?? [] as $f) if (!array_key_exists($f, $doc)) $errors[] = "Missing required field $f";
        foreach ($schema['properties'] ?? [] as $f=>$rules) {
            if (!array_key_exists($f,$doc)) continue;
            $val = $doc[$f];
            if (isset($rules['type']) && gettype($val) !== $rules['type']) $errors[] = "Field $f must be of type {$rules['type']}";
            if (isset($rules['maxLength']) && is_string($val) && strlen($val) > $rules['maxLength']) $errors[] = "Field $f exceeds maxLength {$rules['maxLength']}";
        }
        return ['valid'=>empty($errors),'errors'=>$errors];
    }

    /* -------------------------
       WAL apply helpers (used by SleekDB.replayWal)
       ------------------------- */

    // apply insert without appending to WAL (during replay)
    public function applyInsertFromWal(array $doc) {
        if (!isset($doc['_id'])) $doc['_id'] = $this->db->generateId();
        if (!isset($doc['created_at'])) $doc['created_at'] = date('c');
        file_put_contents($this->path . '/' . $doc['_id'] . '.json', json_encode($doc, JSON_PRETTY_PRINT), LOCK_EX);
        $this->updateIndexesOnInsert($doc);
    }

    public function applyUpdateFromWal(string $id, array $data) {
        $this->updateById($id, $data);
    }

    public function applyDeleteFromWal(string $id) {
        $this->deleteById($id);
    }

    /* -------------------------
       Simple encryption helpers
       ------------------------- */

    private function encrypt(string $text, string $key) {
        $iv = random_bytes(16);
        $cipher = openssl_encrypt($text, 'AES-256-CBC', $key, OPENSSL_RAW_DATA, $iv);
        return base64_encode($iv . $cipher);
    }

    private function decrypt(string $blob, string $key) {
        $raw = base64_decode($blob);
        if ($raw === false || strlen($raw) < 16) return $blob;
        $iv = substr($raw, 0, 16);
        $cipher = substr($raw, 16);
        $plain = openssl_decrypt($cipher, 'AES-256-CBC', $key, OPENSSL_RAW_DATA, $iv);
        return $plain === false ? $blob : $plain;
    }

    /* -------------------------
       Misc helpers (public)
       ------------------------- */

    // Expose collection name
    public function getName() { return $this->name; }
}

/* ============================================================
   End of file footer
   ============================================================ */

echo "\n<!-- Jogu v3.0.0 - SleekDB v3.0 integrated -- Timestamp: " . time() . " -->\n";
/* EOF */
